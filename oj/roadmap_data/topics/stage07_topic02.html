<h2>üéØ M·ª•c ti√™u b√†i h·ªçc</h2>
<ul>
  <li>Hi·ªÉu c√°ch ki·ªÉm tra r√†ng bu·ªôc khi ƒë·∫∑t h·∫≠u (Q) l√™n b√†n c·ªù n√ón.</li>
  <li>Bi·∫øt c·∫Øt t·ªâa nh√°nh sai thay v√¨ th·ª≠ t·∫•t c·∫£ m·ªçi c√°ch m√π qu√°ng.</li>
</ul>

<hr>

<h2>üìò B√†i to√°n N-Queens l√† g√¨?</h2>
<p>
Ta c·∫ßn ƒë·∫∑t n qu√¢n H·∫≠u sao cho:
</p>
<ul>
  <li>Kh√¥ng c√≥ 2 h·∫≠u n√†o c√πng h√†ng.</li>
  <li>Kh√¥ng c√≥ 2 h·∫≠u n√†o c√πng c·ªôt.</li>
  <li>Kh√¥ng c√≥ 2 h·∫≠u n√†o c√πng ch√©o.</li>
</ul>

<p>M·ªói l·ªùi gi·∫£i l√† m·ªôt c√°ch s·∫Øp x·∫øp h·ª£p l·ªá to√†n b·ªô b√†n c·ªù.</p>

<hr>

<h2>üíª √ù t∆∞·ªüng gi·∫£i b·∫±ng quay lui</h2>
<ol>
  <li>ƒê·∫∑t h·∫≠u t·ª´ng h√†ng m·ªôt (row 0, row 1, ...).</li>
  <li>·ªû m·ªói h√†ng, th·ª≠ ƒë·∫∑t v√†o t·ª´ng c·ªôt c√≥ th·ªÉ.</li>
  <li>N·∫øu h·ª£p l·ªá th√¨ ƒëi ti·∫øp sang h√†ng sau, n·∫øu kh√¥ng th√¨ b·ªè (backtrack).</li>
</ol>

<hr>

<h3>C++</h3>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int n;
vector&lt;int&gt; col, diag1, diag2, pos;
int solutions = 0;

void backtrack(int row){
    if(row==n){
        solutions++;
        for(int r=0;r&lt;n;r++){
            for(int c=0;c&lt;n;c++){
                cout &lt;&lt; (pos[r]==c ? "Q" : ".");
            }
            cout &lt;&lt; "\n";
        }
        cout &lt;&lt; "\n";
        return;
    }
    for(int c=0;c&lt;n;c++){
        if(!col[c] && !diag1[row+c] && !diag2[row-c+n-1]){
            col[c]=diag1[row+c]=diag2[row-c+n-1]=1;
            pos[row]=c;
            backtrack(row+1);
            col[c]=diag1[row+c]=diag2[row-c+n-1]=0;
        }
    }
}

int main(){
    cin &gt;&gt; n;
    col.assign(n,0);
    diag1.assign(2*n,0);
    diag2.assign(2*n,0);
    pos.assign(n,-1);
    backtrack(0);
    cerr &lt;&lt; "Total solutions: " &lt;&lt; solutions &lt;&lt; "\n";
}</code></pre>

<h3>Python</h3>
<pre><code>n = int(input())

col   = [False]*n
diag1 = [False]*(2*n)
diag2 = [False]*(2*n)
pos   = [-1]*n
solutions = 0

def backtrack(row):
    global solutions
    if row == n:
        solutions += 1
        for r in range(n):
            line = "".join("Q" if pos[r]==c else "." for c in range(n))
            print(line)
        print()
        return
    for c in range(n):
        if not col[c] and not diag1[row+c] and not diag2[row-c+n-1]:
            col[c] = diag1[row+c] = diag2[row-c+n-1] = True
            pos[row] = c
            backtrack(row+1)
            col[c] = diag1[row+c] = diag2[row-c+n-1] = False

backtrack(0)
print("Total solutions:", solutions)</code></pre>

<hr>

<h2>üß© B√†i t·∫≠p luy·ªán t·∫≠p</h2>
<ol>
  <li>In ra t·ªïng s·ªë l·ªùi gi·∫£i c·ªßa N-Queens v·ªõi n cho tr∆∞·ªõc.</li>
  <li>Ch·ªâ in ra 1 l·ªùi gi·∫£i h·ª£p l·ªá ƒë·∫ßu ti√™n (d·ª´ng s·ªõm).</li>
  <li>Bi·ªÉu di·ªÖn l·ªùi gi·∫£i kh√¥ng ph·∫£i b·∫±ng b·∫£ng Q/. m√† b·∫±ng m·∫£ng v·ªã tr√≠ c·ªôt, v√≠ d·ª•: [1, 3, 0, 2].</li>
</ol>

<details>
  <summary><b>üí° G·ª£i √Ω l·ªùi gi·∫£i d·ª´ng s·ªõm</b></summary>
  <pre><code># Trong backtrack(row):
#   n·∫øu ƒë√£ t√¨m th·∫•y l·ªùi gi·∫£i ƒë·∫ßu ti√™n th√¨ return True ƒë·ªÉ d·ª´ng lu√¥n
#   n·∫øu kh√¥ng th√¨ ti·∫øp t·ª•c th·ª≠.
# ƒê√¢y l√† t·ªëi ∆∞u h√≥a th·ªùi gian khi ch·ªâ c·∫ßn 1 l·ªùi gi·∫£i.</code></pre>
</details>
