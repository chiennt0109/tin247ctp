<h2>🎯 Mục tiêu</h2>
<ul>
  <li>Hiểu cấu trúc cây và cách duyệt (inorder, preorder, postorder).</li>
  <li>Áp dụng nguyên lý BST để tìm kiếm nhanh.</li>
</ul>

<hr>

<h2>📘 Lý thuyết</h2>
<p><b>Cây nhị phân</b> gồm các nút, mỗi nút có tối đa 2 con.  
<b>BST</b> thỏa: giá trị bên trái &lt; nút gốc &lt; giá trị bên phải.</p>

<hr>

<h2>💻 Ví dụ</h2>
<h4>C++</h4>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
struct Node{int val;Node* left;Node* right;Node(int v):val(v),left(NULL),right(NULL){}};
Node* insert(Node* r,int v){
  if(!r) return new Node(v);
  if(v&lt;r->val) r->left=insert(r->left,v);
  else r->right=insert(r->right,v);
  return r;
}
void inorder(Node* r){if(!r)return;inorder(r->left);cout&lt;&lt;r->val&lt;&lt;" ";inorder(r->right);}
int main(){Node* root=NULL;for(int x:{5,3,7,2,4,6,8}) root=insert(root,x);inorder(root);}
</code></pre>

<h4>Python</h4>
<pre><code>class Node:
    def __init__(self,val): self.val=val;self.left=self.right=None
def insert(r,v):
    if not r: return Node(v)
    if v&lt;r.val: r.left=insert(r.left,v)
    else: r.right=insert(r.right,v)
    return r
def inorder(r):
    if not r: return
    inorder(r.left);print(r.val,end=' ');inorder(r.right)
root=None
for x in [5,3,7,2,4,6,8]: root=insert(root,x)
inorder(root)</code></pre>

<hr>

<h2>🧩 Bài tập</h2>
<ol>
  <li>Viết hàm tìm kiếm trong BST.</li>
  <li>Đếm số lá trong cây.</li>
  <li>In cây theo thứ tự giảm dần.</li>
</ol>

<details><summary><b>💡 Lời giải 1 (tìm kiếm)</b></summary>
<pre><code>def search(root,x):
    if not root: return False
    if root.val==x: return True
    return search(root.left,x) if x&lt;root.val else search(root.right,x)
</code></pre>
</details>
